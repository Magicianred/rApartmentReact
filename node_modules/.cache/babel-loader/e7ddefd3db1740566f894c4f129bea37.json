{"ast":null,"code":"import _initializerDefineProperty from \"/home/INVOLVES/leticia.coelho/Documentos/react/rApartmentReact/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"/home/INVOLVES/leticia.coelho/Documentos/react/rApartmentReact/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"/home/INVOLVES/leticia.coelho/Documentos/react/rApartmentReact/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _class, _descriptor, _temp;\n\nimport { proxy } from 'comlink';\nimport { action, observable } from 'mobx';\nimport * as Tone from 'tone';\nimport { speak } from '../lib';\nimport { getTimerWorker } from '../workers/getTimerWorker';\nimport { BaseStore } from './BaseStore';\nexport let TimerStore = (_class = (_temp = class TimerStore extends BaseStore {\n  constructor(...args) {\n    super(...args);\n\n    _initializerDefineProperty(this, \"idle\", _descriptor, this);\n\n    this.synth = new Tone.Synth().toDestination();\n    this.StoreTimerWorker = getTimerWorker();\n    this.timerWorker = void 0;\n  }\n\n  async initWorker() {\n    if (!this.timerWorker) {\n      this.timerWorker = await new this.StoreTimerWorker();\n    }\n  }\n\n  async stopPerformance() {\n    if (!this.timerWorker) return;\n    await this.timerWorker.clearInterval();\n    this.idle = false;\n  }\n\n  timeUpdater(isRecovery, exercise) {\n    return proxy(secondsLeft => {\n      if (!this.idle) return;\n\n      if (exercise) {\n        exercise[isRecovery ? 'recoverySecondsLeft' : 'secondsLeft'] = secondsLeft;\n      }\n\n      if (secondsLeft > 0 && secondsLeft < 4) {\n        this.synth.triggerAttackRelease('C4', '0.2');\n      }\n\n      if (secondsLeft === 0) {\n        this.synth.triggerAttackRelease('G4', '0.4');\n      }\n    });\n  }\n\n  async startPerformance() {\n    await this.initWorker();\n    this.idle = true;\n\n    for (let [roundId, roundData] of this.root.round.rounds) {\n      this.log(`Round: ${roundId}`);\n      if (!this.idle) break;\n\n      for (let i = 0; i < roundData.exercises.length; i++) {\n        if (!this.timerWorker) {\n          throw new Error('You cannot start timer with no worker');\n        }\n\n        if (!this.idle) break;\n        const exercise = roundData.exercises[i];\n        await speak(`Get ready for ${exercise.exerciseTime} seconds of ${exercise.name}.`);\n        await this.timerWorker.runTimer(5, this.timeUpdater());\n        await this.timerWorker.runTimer(exercise.exerciseTime, this.timeUpdater(false, exercise));\n        await speak(`Rest for ${exercise.recoveryTime} seconds.`);\n        await this.timerWorker.runTimer(exercise.recoveryTime, this.timeUpdater(true, exercise));\n      }\n    }\n\n    this.idle = false;\n    speak('Congratulations! You completed your workout.');\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"idle\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"stopPerformance\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"stopPerformance\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"startPerformance\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"startPerformance\"), _class.prototype)), _class);","map":{"version":3,"sources":["/home/INVOLVES/leticia.coelho/Documentos/react/rApartmentReact/src/store/TimerStore.ts"],"names":["proxy","action","observable","Tone","speak","getTimerWorker","BaseStore","TimerStore","synth","Synth","toDestination","StoreTimerWorker","timerWorker","initWorker","stopPerformance","clearInterval","idle","timeUpdater","isRecovery","exercise","secondsLeft","triggerAttackRelease","startPerformance","roundId","roundData","root","round","rounds","log","i","exercises","length","Error","exerciseTime","name","runTimer","recoveryTime"],"mappings":"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","sourcesContent":["import { proxy } from 'comlink'\nimport { action, observable } from 'mobx'\nimport * as Tone from 'tone'\nimport { speak } from '../lib'\nimport { getTimerWorker } from '../workers/getTimerWorker'\nimport type { TimerWorker } from '../workers/timer-worker'\nimport { BaseStore } from './BaseStore'\n\nexport class TimerStore extends BaseStore {\n  @observable\n  idle = false\n  synth = new Tone.Synth().toDestination()\n  StoreTimerWorker = getTimerWorker()\n  timerWorker?: TimerWorker\n\n  async initWorker() {\n    if (!this.timerWorker) {\n      this.timerWorker = await new this.StoreTimerWorker()\n    }\n  }\n\n  @action\n  async stopPerformance() {\n    if (!this.timerWorker) return\n\n    await this.timerWorker.clearInterval()\n    this.idle = false\n  }\n\n  private timeUpdater(isRecovery?: boolean, exercise?: ExerciseData) {\n    return proxy((secondsLeft: number) => {\n      if (!this.idle) return\n\n      if (exercise) {\n        exercise[\n          isRecovery ? 'recoverySecondsLeft' : 'secondsLeft'\n        ] = secondsLeft\n      }\n\n      if (secondsLeft > 0 && secondsLeft < 4) {\n        this.synth.triggerAttackRelease('C4', '0.2')\n      }\n\n      if (secondsLeft === 0) {\n        this.synth.triggerAttackRelease('G4', '0.4')\n      }\n    })\n  }\n\n  @action\n  async startPerformance() {\n    await this.initWorker()\n\n    this.idle = true\n\n    for (let [roundId, roundData] of this.root.round.rounds) {\n      this.log(`Round: ${roundId}`)\n      if (!this.idle) break\n\n      for (let i = 0; i < roundData.exercises.length; i++) {\n        if (!this.timerWorker) {\n          throw new Error('You cannot start timer with no worker')\n        }\n        if (!this.idle) break\n\n        const exercise = roundData.exercises[i]\n\n        await speak(\n          `Get ready for ${exercise.exerciseTime} seconds of ${exercise.name}.`\n        )\n        await this.timerWorker.runTimer(5, this.timeUpdater())\n        await this.timerWorker.runTimer(\n          exercise.exerciseTime,\n          this.timeUpdater(false, exercise)\n        )\n        await speak(`Rest for ${exercise.recoveryTime} seconds.`)\n        await this.timerWorker.runTimer(\n          exercise.recoveryTime,\n          this.timeUpdater(true, exercise)\n        )\n      }\n    }\n\n    this.idle = false\n    speak('Congratulations! You completed your workout.')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}